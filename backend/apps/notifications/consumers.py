content='import json\nimport logging\nfrom channels.generic.websocket import AsyncWebsocketConsumer\nfrom channels.db import database_sync_to_async\nfrom django.contrib.auth.models import AnonymousUser\nfrom django.core.exceptions import ValidationError\nfrom .models import Notification\nfrom ..authentication.models import User\n\nlogger = logging.getLogger(__name__)\n\n\nclass NotificationConsumer(AsyncWebsocketConsumer):\n    """\n    WebSocket consumer for handling real-time notifications.\n    Manages user-specific notification channels and message broadcasting.\n    """\n\n    async def connect(self):\n        """\n        Handle WebSocket connection establishment.\n        Authenticates user and adds them to their notification group.\n        """\n        try:\n            # Get user from scope (set by authentication middleware)\n            self.user = self.scope.get(\'user\')\n            \n            if isinstance(self.user, AnonymousUser) or not self.user:\n                logger.warning("Anonymous user attempted to connect to notifications")\n                await self.close(code=4001)\n                return\n\n            # Create user-specific group name\n            self.user_group_name = f"notifications_{self.user.id}"\n            \n            # Add user to their notification group\n            await self.channel_layer.group_add(\n                self.user_group_name,\n                self.channel_name\n            )\n\n            # Accept the WebSocket connection\n            await self.accept()\n            \n            # Send connection confirmation\n            await self.send(text_data=json.dumps({\n                \'type\': \'connection_established\',\n                \'message\': \'Connected to notifications\',\n                \'user_id\': self.user.id\n            }))\n            \n            # Send any unread notifications\n            await self.send_unread_notifications()\n            \n            logger.info(f"User {self.user.id} connected to notifications")\n\n        except Exception as e:\n            logger.error(f"Error in notification consumer connect: {str(e)}")\n            await self.close(code=4000)\n\n    async def disconnect(self, close_code):\n        """\n        Handle WebSocket disconnection.\n        Removes user from their notification group.\n        """\n        try:\n            if hasattr(self, \'user_group_name\'):\n                await self.channel_layer.group_discard(\n                    self.user_group_name,\n                    self.channel_name\n                )\n                logger.info(f"User {getattr(self.user, \'id\', \'unknown\')} disconnected from notifications")\n        except Exception as e:\n            logger.error(f"Error in notification consumer disconnect: {str(e)}")\n\n    async def receive(self, text_data):\n        """\n        Handle incoming WebSocket messages from client.\n        Processes notification actions like marking as read.\n        """\n        try:\n            data = json.loads(text_data)\n            message_type = data.get(\'type\')\n            \n            if message_type == \'mark_as_read\':\n                await self.handle_mark_as_read(data)\n            elif message_type == \'mark_all_as_read\':\n                await self.handle_mark_all_as_read()\n            elif message_type == \'get_unread_count\':\n                await self.send_unread_count()\n            else:\n                await self.send_error(\'Invalid message type\')\n                \n        except json.JSONDecodeError:\n            await self.send_error(\'Invalid JSON format\')\n        except Exception as e:\n            logger.error(f"Error processing notification message: {str(e)}")\n            await self.send_error(\'Internal server error\')\n\n    async def handle_mark_as_read(self, data):\n        """\n        Mark a specific notification as read.\n        """\n        try:\n            notification_id = data.get(\'notification_id\')\n            if not notification_id:\n                await self.send_error(\'notification_id is required\')\n                return\n\n            success = await self.mark_notification_as_read(notification_id)\n            \n            if success:\n                await self.send(text_data=json.dumps({\n                    \'type\': \'notification_marked_read\',\n                    \'notification_id\': notification_id,\n                    \'success\': True\n                }))\n                await self' additional_kwargs={} response_metadata={'id': 'msg_01QzTrCjvf17QFVDg8n8EXAP', 'model': 'claude-sonnet-4-20250514', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 406, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--4c7412a6-abb6-41c0-9796-daa19dc0bfef-0' usage_metadata={'input_tokens': 406, 'output_tokens': 1024, 'total_tokens': 1430, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}